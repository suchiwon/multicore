#  멀티코어 프로그래밍 Project2 README #
<br>
## 1. 컴파일 및 실행 방법 ##
프로젝트 경로의 최상위에 Makefile이 있으므로 make clean 명령으로 bin 경로와 텍스트 파일을 제거 후 make 명령으로 컴파일 하시면 bin/project2 실행 파일이 컴파일 됩니다.
실행은 bin/project2 [스레드 수] [실행 시간(초)] [verbose] 형식으로 인자를 주어 실행하면 됩니다.
예를 들어 bin/project2 5 30 verbose 명령을 입력하면 스레드 5개를 생성해 30초 동안 실행하고 각 스레드의 correct 확인용 파일을 생성해 출력합니다.
<br>
## 2.프로젝트 코드 구조 ##
####	-include 경로 
헤더 파일들을 모아놓은 경로입니다.
<br><br>
**global.h:** 전역변수들을 선언하는 헤더 파일입니다.
<br>
**singlelist.h:** 활성화 스레드, read_view, 스레드 버전 등을 저장하는 리스트 구조와 리스트의 탐색,삽입,삭제 등의 기능 함수들을 선언하는 헤더 파일입니다.<br>
전역변수 중 리스트 헤더 등 리스트에 관련된 변수들은 이 파일이 선언되어 있습니다.<br>

####	-src 경로
코드 파일들을 모아놓은 경로입니다.
<br><br>
**global.cpp:** global.h에서 선언된 함수를 정의하는 코드 파일입니다.
<br>
**mvcc.cpp:** 각 스레드의 실행 함수를 정의하는 코드 파일입니다.
<br>
**garbagecollector.cpp:** 스레드의 버전 중 더 이상 사용하지 않는 버전(리스트의 노드)를 삭제하는 가비지 콜렉터 기능 함수를 정의하는 코드 파일입니다.
<br>
**bakerylock.cpp:** 락의 구현 중 램포트의 빵집 알고리즘의 기능 함수와 이 알고리즘에 사용하는 전역변수들을 선언하는 코드 파일입니다.
<br>
**filterlock.cpp:** 락의 구현 중 필터 잠금의 기능 함수와 이 알고리즘에 사용하는 전역변수들을 선언하는 코드 파일입니다. 위의 bakerylock의 코드와 이 코드 중 하나를 사용합니다.
**main.cpp:** 메인 함수를 정의하는 코드 파일입니다.
<br>

## 3.구현 알고리즘 ##
기본적인 틀은 프로젝트의 설명문과 교수님, 조교님들의 설명에 따라 구현했습니다.
<br><br>
**리스트:** 모든 리스트는 싱글 포인터 리스트로 탐색시 다음 노드 방향으로만 가능합니다. 리스트의 헤더 중 업데이트 활성화 스레드와 각 스레드의 버전 저장 리스트의 헤더는 전역 변수로 정의되어 모든 스레드가 접근 가능하고 각 스레드가 업데이트 시 참고할 readview는 각 스레드의 지역 변
수로 선언되어 있습니다.<br>
각 스레드의 버전 저장 리스트는 버전에 따라 내림차순으로 정렬되어 있어 가장 최신 버전이 헤더의 다음 노드에 위치합니다. 따라더 리스트의 탐색은 가장 최신 버전 부터 시작합니다.<br>
**스레드 기능 방식:** 각 스레드는 초기화 시 A,B를 랜덤으로 생성하고 버전 0으로 자신의 최초의 버전으로 추가 후 업데이트를 시작합니다. 이 때, 자신의 최신 버전을 빠르게 탐색할 수 있게 하나의 노드 구조체를 따로 가져서 최신 버전 정보를 따로 저장해 놓습니다.<br>
초기화 후, while 루프 내부에서 업데이트 지점에서 전역변수인 현재 버전을 증가 후 가져와 활성화 스레드 리스트에 추가 후 자신의 readview 리스트에 복사해옵니다. 이 때, 활성화 스레드의 변형 중 충돌이 일어나면 안되므로 락을 걸고 진행하고 종료시 해제합니다. 또한 가비지 콜렉트에 사용할 업데이트 중 가장 오래된 버전의 계산도 동시에 행합니다.<br>
그 후, 읽어올 스레드를 정한 후 readview에 그 스레드가 업데이트 중인지를 파악합니다. readview에 존재한다는 의미는 그 버전은 업데이트 중이어서 변화될 가능성이 있는 값이므로 그 이전 버전을 읽어야 한다는 뜻입니다.<br>
readview의 탐색 후에 선택한 스레드의 버전 리스트를 탐색하면서 안전한 버전의 값을 읽어서 업데이트 합니다. 이 때, 안전한 버전은 자신의 현재 업데이트 버전보다 낮고 업데이트 중이 아닌 버전 중 가장 최신 버전입니다. 이 버전은 내림차순으로 정렬되어있는 리스트에서 자신보다 낮은 버전이 나올때까지 탐색 시 진행할 경우 나오게 됩니다. 이 후, 활성화 스레드 리스트에서 자신을 제거하고 처음으로 돌아갑니다.
<br><br>

## 4.알고리즘의 정당성 ##
알고리즘의 정당성은 읽어도 안전한 값만을 읽는다는 것을 보장함을 보여야 하는 것입니다. 여기서 읽어도 안전한 값은 자신이 업데이트 시에 존재하는 버전 즉, 자신보다 낮은 버전이고 그 중 각 스레드에서 최신 버전만이 실제 값으로 존재하는 것이므로 그 값만을 읽어야 합니다. 한 스레드에서 자신의 업데이트 버전 보다 높은 버전을 가질 때에는 자신이 업데이트 중 context switch로 멈춘 동안 다른 스레드가 여러번의 업데이트를 거친 상태이므로 스레드 시간 경과 상으로<br>
<--> <--> <--> <--> <--><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<--------------------><br>
의 형태를 취하게 됩니다. 아래의 스레드 시간의 기간 중 위의 스레드의 첫 번째 업데이트(맨 왼쪽 기간/자신의 업데이트 전 완료 버전) 종료 후 시간에서 두 번째 업데이트(자신의 업데이트 버전 전 업데이트 중인 버전) 종료 전 시간 사이에서 read 하면 linearizable을 만족하므로 mvcc 버전 형식을 이용해 그림 상에서 맨 앞 버전의 값을 읽어야 하는 것입니다. 반대로 그림의 첫 번째 이전 버전의 값을 읽으면 linearizable하지 않으므로 저 버전의 값만을 읽어야 합니다.
<br><br>

## 5.락의 성능 ##
활성화 스레드 리스트의 삽입, 복사, 삭제에서 동시에 여러개의 스레드가 작업할 시 충돌이 일어날 수 있으므로 이 구간에서 락을 사용하게 되는데 사용하는 락은 pthread 클래스에 정의되어있는 mutex lock과 bakery,filter algorithm을 구현 하고 그 중 bakery lock을 사용하였습니다.<br>
락의 구현에서의 문제점은 미리 작성되어 제공된 mutex의 경우 작동에 문제가 없었으나 직접 작성한 bakery,filter lock은 적용시 다른 스레드의 unlock 대기시(while문 spin 대기 부분) delay를 주지 않을 경우 deadlock이 걸리는 문제가 발생했습니다. 이 부분에 대한 문제는 현재 해결 하지 못하여서 delay를 적용할 결과 lock의 성능이 매우 떨어지게 되었습니다.<br>
성능 비교는 프로그램을 스레드 갯수를 조절하면서 실행 시간은 30초로 고정 후 실행 결과로 비교했습니다. 실행 환경은 코어 2개이고 가비지 콜렉션 스레드가 추가로 1개 생성됩니다.<br>
mutex lock을 사용할 시 초당 업데이트 횟수와 fairness는<br>
스레드 1개에서 513886 ~ 538239/1.0<br>
스레드 2개에서 581413 ~ 634863/0.995 ~ 0.997<br>
스레드 5개에서 430810 ~ 433356/0.998 ~ 0.999<br>
스레드 10개에서 399556 ~ 406376/0.998 ~ 0.998<br>
결과 스레드 갯수의 증가에 따라 업데이트 횟수는 감소하지만 fairness에는 영향이 없음을 확인 할 수 있습니다.<br>
이에 비해 bakery lock을 사용할 시 초당 업데이트 횟수와 fairness는<br>
스레드 1개에서 481719 ~ 539263/1.0<br>
스레드 2개에서 1759 ~ 1823/0.991 ~ 0.998<br>
스레드 5개에서 1296 ~ 1328/0.999 ~ 0.999<br>
스레드 10개에서 1284 ~ 1401/0.962 ~ 0.999<br>
스레드 1개에서는 delay의 영향을 받지 않으므로 mutex lock과 비슷한 결과를 보이나 스레드 2개에서 부터 delay의 영향으로 업데이트 속도가 현저히 감소함을 보이고 있습니다. 

## 6.가비지 콜렉터 ##
각 스레드가 실행되면서 버전을 업데이트 하는데 버전이 계속 쌓일 경우 메모리에 한계가 오므로 더 이상 사용하지 않는 버전을 삭제하는 역할을 가비지 콜렉터가 맡게 됩니다. 현재 가비지 콜렉터 스레드는 1개를 돌리고 있습니다. 가비지 콜렉터는 각 스레드가 활성화 스레드 리스트를 복사시에 검색해 가장 오래된 활성화 스레드 버전을 전역 변수에 저장해주면 각 스레드를 계속 돌아 스레드 버전 중 전역 변수 버전보다 아래 버전의 다음 노드들을 전부 지우는 작업을 하게 됩니다. 리스트에서 삭제를 할 때 락을 걸지 않기 때문에 같은 리스트에 스레드와 동시에 접근할 경우가 생기는데 이 때 스레드는 헤더에서 부터 자신의 업데이트 버전보다 낮은 버전까지만 탐색하고 만약 readview에 존재했다면 그 다음 버전까지만 탐색하는데 가비지 콜렉터는 이 탐색 지점 이후의 노드를 지우므로 서로에게 영향을 주지 않습니다.

